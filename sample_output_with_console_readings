
# ==========================================
# STRICT RECURSIVE WRAPPER (V4.4)
# ==========================================
import datetime
import sys
import os
import builtins  # CRITICAL: Access original print

_AD_DEBUG_ACTIVE = True
_ORIGINAL_PRINT = builtins.print  # Save the real print function

def _ad_script_output(msg, is_error=True):
    if not _AD_DEBUG_ACTIVE: return
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    if is_error:
        formatted = f"[DEBUG_ERROR] [{timestamp}] {msg}"
    else:
        # For general script output, we use the requested tag
        formatted = f"[SCRIPTATLARGE] {msg}"

    # CRITICAL: Use the original print to avoid recursion loop
    _ORIGINAL_PRINT(formatted)

    try:
        with open("_DEBUG_CRASH_LOG.txt", "a", encoding="utf-8") as f:
            f.write(formatted + "\n")
    except: pass

# Redirecting standard print to ensure all script output is tagged
def print(*args, **kwargs):
    # This captures script prints and routes them to our labeled output
    output = " ".join(map(str, args))
    _ad_script_output(output, is_error=False)

# ==========================================

import time
import urllib.request
import sys
import os
import csv
from collections import Counter


def find_strict_anagrams(user_input, max_words=5, split_limit=29999):
    
    try:
        print("[1/3] Loading Resources...")
    except Exception as e:
        _ad_script_output(f'Line 11 Failed: {e}', is_error=True)

    try:
        blacklist_file = "blacklist.csv"
    except Exception as e:
        _ad_script_output(f'Line 13 Failed: {e}', is_error=True)
    try:
        blacklist = set()
    except Exception as e:
        _ad_script_output(f'Line 14 Failed: {e}', is_error=True)
    try:
        default_blacklist = ['ca', 'ny', 'tx', 'fl', 'wa', 'al', 'ok', 'id', 'oh', 'or', 'la', 'ncaa']
    except Exception as e:
        _ad_script_output(f'Line 15 Failed: {e}', is_error=True)

    
    if not os.path.exists(blacklist_file):
        try:
            with open(blacklist_file, "w", newline='') as f:
                try:
                    writer = csv.writer(f)
                except Exception as e:
                    _ad_script_output(f'Line 21 Failed: {e}', is_error=True)
                try:
                    writer.writerow(["Category", "Uniques"])
                except Exception as e:
                    _ad_script_output(f'Line 22 Failed: {e}', is_error=True)
                for word in default_blacklist:
                    try:
                        writer.writerow(["Default", word])
                    except Exception as e:
                        _ad_script_output(f'Line 24 Failed: {e}', is_error=True)
            try:
                blacklist = set(default_blacklist)
            except Exception as e:
                _ad_script_output(f'Line 25 Failed: {e}', is_error=True)
        except Exception as e:
            try:
                print(f"   > Error creating CSV: {e}")
            except Exception as e:
                _ad_script_output(f'Line 27 Failed: {e}', is_error=True)
    else:
        try:
            with open(blacklist_file, "r", newline='') as f:
                try:
                    reader = csv.DictReader(f)
                except Exception as e:
                    _ad_script_output(f'Line 31 Failed: {e}', is_error=True)
                if reader.fieldnames and 'Uniques' in reader.fieldnames:
                    for row in reader:
                        try:
                            val = row.get('Uniques', '').strip().lower()
                        except Exception as e:
                            _ad_script_output(f'Line 34 Failed: {e}', is_error=True)
                        if val: blacklist.add(val)
        except Exception as e:
            try:
                print(f"   > Error reading CSV: {e}")
            except Exception as e:
                _ad_script_output(f'Line 37 Failed: {e}', is_error=True)

    
    try:
        url = "https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-no-swears.txt"
    except Exception as e:
        _ad_script_output(f'Line 40 Failed: {e}', is_error=True)
    try:
        with urllib.request.urlopen(url) as response:
            try:
                raw_words = response.read().decode('utf-8').splitlines()
            except Exception as e:
                _ad_script_output(f'Line 43 Failed: {e}', is_error=True)
    except Exception as e:
        try:
            print(f"Error fetching dictionary: {e}")
        except Exception as e:
            _ad_script_output(f'Line 45 Failed: {e}', is_error=True)
        try:
            return
        except Exception as e:
            _ad_script_output(f'Line 46 Failed: {e}', is_error=True)

    
    try:
        clean_target = "".join(filter(str.isalpha, user_input.lower()))
    except Exception as e:
        _ad_script_output(f'Line 49 Failed: {e}', is_error=True)
    try:
        target_count = Counter(clean_target)
    except Exception as e:
        _ad_script_output(f'Line 50 Failed: {e}', is_error=True)

    try:
        candidates = []
    except Exception as e:
        _ad_script_output(f'Line 52 Failed: {e}', is_error=True)
    for word in raw_words:
        try:
            w = word.lower()
        except Exception as e:
            _ad_script_output(f'Line 54 Failed: {e}', is_error=True)
        if (len(w) < 3 and w not in ['a', 'i']) or w in blacklist:
            continue
        try:
            w_count = Counter(w)
        except Exception as e:
            _ad_script_output(f'Line 57 Failed: {e}', is_error=True)
        if all(w_count[c] <= target_count[c] for c in w_count):
            try:
                candidates.append(w)
            except Exception as e:
                _ad_script_output(f'Line 59 Failed: {e}', is_error=True)
    try:
        candidates.sort(key=len, reverse=True)
    except Exception as e:
        _ad_script_output(f'Line 60 Failed: {e}', is_error=True)

    
    try:
        print(f"[2/3] Searching for phrases in '{user_input}'...")
    except Exception as e:
        _ad_script_output(f'Line 63 Failed: {e}', is_error=True)

    try:
        found_hashes = set()
    except Exception as e:
        _ad_script_output(f'Line 65 Failed: {e}', is_error=True)
    try:
        matches = 0
    except Exception as e:
        _ad_script_output(f'Line 66 Failed: {e}', is_error=True)
    try:
        file_index = 1
    except Exception as e:
        _ad_script_output(f'Line 67 Failed: {e}', is_error=True)
    try:
        current_entries = 0
    except Exception as e:
        _ad_script_output(f'Line 68 Failed: {e}', is_error=True)
    try:
        current_part_file = None
    except Exception as e:
        _ad_script_output(f'Line 69 Failed: {e}', is_error=True)

    
    try:
        safe_name = "".join(x for x in user_input if x.isalnum())[:15]
    except Exception as e:
        _ad_script_output(f'Line 72 Failed: {e}', is_error=True)
    try:
        master_filename = f"MASTER_list_{safe_name}_{str(time.time())}.txt"
    except Exception as e:
        _ad_script_output(f'Line 73 Failed: {e}', is_error=True)
    try:
        master_file = open(master_filename, "w")
    except Exception as e:
        _ad_script_output(f'Line 74 Failed: {e}', is_error=True)
    master_file.write("[")  

    def get_part_file():
        nonlocal current_part_file, file_index, current_entries
        if current_part_file is None or current_entries >= split_limit:
            if current_part_file: current_part_file.close()
            fname = f"anagram_res_{safe_name}_{str(time.time())}_{file_index}.txt"
            current_part_file = open(fname, "w")
            file_index += 1
            current_entries = 0
        return current_part_file

    def backtrack(path, pool):
        nonlocal matches, current_entries
        if sum(pool.values()) == 0:
            phrase_hash = tuple(sorted(path))
            if phrase_hash not in found_hashes:
                phrase_str = " ".join(path).title()

                
                if matches > 0:
                    master_file.write(", ")
                master_file.write(phrase_str)

                
                get_part_file().write(phrase_str + "\n")

                found_hashes.add(phrase_hash)
                matches += 1
                current_entries += 1

                if matches % 100 == 0:
                    sys.stdout.write(f'\râœ¨ Found {matches}...')
                    sys.stdout.flush()
            return

        if len(path) >= max_words: return
        for word in candidates:
            if len(word) > sum(pool.values()): continue
            w_count = Counter(word)
            if all(pool[c] >= w_count[c] for c in w_count):
                backtrack(path + [word], pool - w_count)

    
    for i, root in enumerate(candidates):
        sys.stdout.write(f'\rProgress: {(i / len(candidates)) * 100:.1f}% ')
        backtrack([root], target_count - Counter(root))

    
    master_file.write("}")  
    try:
        master_file.close()
    except Exception as e:
        _ad_script_output(f'Line 125 Failed: {e}', is_error=True)
    if current_part_file: current_part_file.close()

    try:
        print(f"\n[3/3] Done!")
    except Exception as e:
        _ad_script_output(f'Line 128 Failed: {e}', is_error=True)
    try:
        print(f" > Standard parts created: {file_index - 1} file(s)")
    except Exception as e:
        _ad_script_output(f'Line 129 Failed: {e}', is_error=True)
    try:
        print(f" > Master comma-list created: {master_filename}")
    except Exception as e:
        _ad_script_output(f'Line 130 Failed: {e}', is_error=True)



try:
    u_in = input("Enter phrase: ")
except Exception as e:
    _ad_script_output(f'Line 134 Failed: {e}', is_error=True)
try:
    find_strict_anagrams(u_in)
except Exception as e:
    _ad_script_output(f'Line 135 Failed: {e}', is_error=True)
